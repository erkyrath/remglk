<!doctype HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<title>RemGlk: remote-procedure-call implementation of the Glk IF API</title>

<style type="text/css">

body {
  margin-left: 20px;
  margin-right: 20px;
}

h2 {
  font-family: Gill Sans, Helvetica, Arial, sans-serif;
  font-weight: normal;
}

h3 {
  font-family: Gill Sans, Helvetica, Arial, sans-serif;
  font-weight: normal;
}

h4 {
  font-family: Gill Sans, Helvetica, Arial, sans-serif;
  font-weight: normal;
}

h2 a {
  border-bottom: 1px dotted #AAA;
}

h3 a {
  border-bottom: 1px dotted #AAA;
}

h4 a {
  border-bottom: 1px dotted #AAA;
}

ul {
  list-style-type: none;
  padding-left: 24px;
}

li {
  margin-top: 2px;
}

dt {
  margin-top: 4px;
}

.ContentTop > li > a {
  border-left: 2px solid #AAA;
  padding-left: 8px;
}

.ContentTop > li > ul {
  border-left: 2px dotted #DDD;
}

.Def {
  margin-left: 4px;
  background: #D0F8D4;
  border-left: 4px solid #98E0A0;
  padding: 4px 0px 4px 8px;
}

.Sample {
  margin-left: 20px;
  margin-right: 30px;
  background: #E0F0C0;
  padding: 4px 0px 4px 8px;
}

.Huge {
  margin-left: 20px;
  background: #E0F0C0;
  max-width: 90%;
  height: 300px;
  overflow: scroll;
  padding: 4px 4px 4px 8px;
}

.Diagram {
  margin-left: 20px;
  margin-right: 30px;
  background: #F8E8C0;
  padding: 4px 0px 4px 8px;
}

.Inline {
  background: #E0F0C0;
  padding-left: 2px;
  padding-right: 2px;
}

</style>

</head>
<body>

<h1>RemGlk: remote-procedure-call implementation of the Glk IF API</h1>

<em>RemGlk version 0.2.1</em><br>

<em>Designed by Andrew Plotkin (erkyrath@eblong.com)<br>
<a href="http://eblong.com/zarf/glk/index.html">Glk home page)</a></em>
<p>

This documentation is licensed under a 
<a href="http://creativecommons.org/licenses/by-nc-sa/3.0">Creative
Commons Attribution-Noncommercial-Share Alike 3.0 Unported License</a>.
<p>

<hr>

<h2>What is RemGlk?</h2>

RemGlk is a C library which implements the <a href="http://eblong.com/zarf/glk/index.html">Glk API</a>. You can compile a Glk application and link it with this library.
<p>

RemGlk does not provide a user interface. Instead, it wraps up the application's output as a <a href="http://json.org/">JSON data structure</a> and sends it to stdout. It then waits for input to arrive from stdin; the input data must also be encoded as JSON.
<p>

RemGlk is therefore like CheapGlk, in that it works entirely through input and output streams, and can easily be attached to a bot or web service. However, unlike CheapGlk, RemGlk supports multiple Glk windows and most Glk I/O features. Whatever it's attached to just has to decode the structured output and display it appropriately.
<p>

RemGlk was designed to complement the <a href="http://eblong.com/zarf/glk/glkote.html">GlkOte</a> Javascript library. GlkOte more or less implements the other half of the job: it accepts game output (as Javascript objects), displays it, and then returns the player's commands in the same format. It should be possible to connect an IF interpreter, RemGlk, and GlkOte to build a complete IF web service.
<p>

<em>Warning: this has not yet been tested in any way. This is an alpha release of RemGlk, and nothing is guaranteed.</em>
<p>

While this is labelled "release 0.2", I may be fixing bugs and adding features iteratively in the near future. Or not. You are best advised to follow my <a href="http://github.com/erkyrath/remglk/">GitHub repository</a> for updates.
<p>

<h2>Using RemGlk</h2>

<h3>Starting up</h3>

Once you have compiled your application, run it as usual. For glulxe, this probably looks like:
<p>

<pre class="Sample">
glulxe Advent.ulx
</pre>
<p>

If you do this, you will see nothing at first. The application is waiting for an initial input which describes the display and font sizes. Try typing this, exactly:
<p>

<pre class="Sample">
{ "type": "init", "gen": 0, "metrics": { "width":80, "height":24 } }
</pre>
<p>

This tells RemGlk that it has an 80x24 "screen" to work with. The default "font size" is 1, so this gives the effect of an 80x24 terminal window.
<p>

If you instead entered:

<pre class="Sample">
{ "type": "init", "gen": 0, "metrics": { "width":400, "height":600,
  "charwidth":12, "charheight":14 } }
</pre>
<p>

...you would get a layout for a 400x600 pixel window, assuming a 14-point font with 12-pixel-wide characters.
<p>

(The font size is only critical for grid (status) windows. You can approximate the measurements for buffer (story) windows; these typically have proportional fonts and perhaps various font sizes as well.)
<p>

The metrics object also allows you to specify margins and border spacing, which improve the layout behavior. See below for details.
<p>

Alternatively, you can specify basic layout information on the command line. If you type:

<pre class="Sample">
glulxe -fm -width 80 -height 50 Advent.ulx
</pre>
<p>

...then the application will <em>not</em> wait for an <code>init</code> event. (And you should not enter one.) Instead, the game will start immediately (with an 80x50 "terminal window"), and send its first screenful of output.
<p>

<h3>The first screen of output</h3>

For <em>Adventure</em>, the initial output looks something like:

<pre class="Sample">
{"type":"update", "gen":1,
 "windows":[
 { "id":25, "type":"grid", "rock":202,
   "gridwidth":80, "gridheight":1,
   "left":0, "top":0, "width":80, "height":1 },
 { "id":22, "type":"buffer", "rock":201,
   "left":0, "top":1, "width":80, "height":49 } ],
 "content":[
 {"id":25, "lines": [
  { "line":0, "content":[{ "style":"normal", "text":" At End Of Road
     Score: 36    Moves: 1      "}]}
 ] },
 {"id":22, "clear":true, "text": [
  {"append":true},
  {}, {}, {}, {}, {},
  {"content":[{ "style":"normal", "text":"Welcome to Adventure!"}]},
  {},
  {"content":[{ "style":"header", "text":"ADVENTURE"}]},
  {"content":[{ "style":"normal", "text":"The Interactive Original"}]},
  {"content":[{ "style":"normal", "text":"By Will Crowther (1973)
     and Don Woods (1977)"}]},
  {"content":[{ "style":"normal", "text":"Reconstructed in three steps by:"}]},
  {"content":[{ "style":"normal", "text":"Donald Ekman, David M. Baggett (1993)
     and Graham Nelson (1994)"}]},
  {"content":[{ "style":"normal", "text":"[In memoriam Stephen Bishop
     (1820?-1857): GN]"}]},
  {"content":[{ "style":"normal", "text":"Release 5 / Serial number
     961209 / Inform v6.21(G0.33) Library 6/10 "}]},
  {},
  {"content":[{ "style":"subheader", "text":"At End Of Road"}]},
  {"content":[{ "style":"normal", "text":"You are standing at the end of
     a road before a small brick building. Around you is a forest. A small
     stream flows out of the building and down a gully."}]},
  {},
  {"content":[{ "style":"normal", "text":"&gt;"}]}
 ] } ],
 "input":[
 {"id":22, "gen":1, "type":"line", "maxlen":256 }
 ]}
</pre>
<p>

This is just to give you a feel for what's going on. Roughly, this says:
<p>

<ul>
<li>First update.
<li>Two windows have been opened:
<ul>
<li>A grid (status) window, ID number 25, 80 characters wide, 1 line high;
<li>A buffer (story) window, ID number 22.
</ul>
<li>Both windows were updated this cycle:
<ul>
<li>Window 25 (the status window), line zero, contains the room name and score.
<li>Window 22 (the story window) contains the initial game text.
<ul>
<li>(Each line contains some content, in some style. It so happens that we don't see any mid-line style changes, although they're perfectly possible. {} is a blank line.)
</ul>
</ul>
<li>One window is requesting input this cycle:
<ul>
<li>Window 22 (the story window) requests line input, up to 256 characters' worth.
</ul>
</ul>

(The window ID numbers will vary from run to run, by the way. Window rock numbers are consistent for a given game, but may vary from game to game.)
<p>

<h3>The first input</h3>

A human types "go east" into some user interface, which then passes the following input to RemGlk:
<p>

<pre class="Sample">
{ "type":"line", "gen":1, "window":22, "value":"go east"}
</pre>
<p>

The library accepts this, mulls it, and generates a new output update. So it goes.
<p>

<h2>The Data Format</h2>

<em>I have not written out this documentation in detail yet. Please refer to the <a href="http://eblong.com/zarf/glk/glkote/docs.html">GlkOte documentation</a>. Input what GlkOte outputs, and vice versa.</em>
<p>

Prior to version 0.2.1, this library used <code>contents</code> and <code>inputs</code> as the names of the top-level data fields, rather than the correct <code>content</code> and <code>input</code>. The prior version also omitted the <code>xpos</code> and <code>ypos</code> fields for grid window input.
<p>

A note on <a href="http://json.org/">JSON</a>: this is a strict (in both senses) subset of Javascript's data literal format. The biggest differences are: you always use double quotes, never single quotes; strings are always quoted, but numbers never are; an object (dictionary) always has quotes around its keys.
<p>

All input and output is UTF-8.
<p>

<hr>
Last updated January 27, 2014.
<p>

<em><a href="http://eblong.com/zarf/glk/index.html">Glk home page</a></em>
<p>

</body>
</html>
